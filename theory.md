# Теоретичне підґрунтя: Патерн "Репозиторій" та Django ORM

## 1. Принципи патерну "Репозиторій"

Патерн "Репозиторій" — це шаблон проєктування, який діє як **посередник** між бізнес-логікою програми та джерелом даних (наприклад, базою даних).

Уявіть, що ваша база даних — це величезний склад, а бізнес-логіка (яка обраховує статистику, додає коментарі) — це менеджери в офісі. Замість того, щоб кожен менеджер бігав на склад і шукав потрібні документи (пишучи SQL-запити), ви наймаєте **архіваріуса (Репозиторій)**.

Тепер менеджери просто дають йому завдання: "дай мені досьє клієнта №123" (`get_by_id(123)`) або "поклади цей новий документ у папку" (`add(model)`). Архіваріус сам знає, на якій полиці що лежить і як правильно це дістати.

### Основні принципи:

1.  **Абстракція (Abstraction):**
    Бізнес-логіка (менеджер) не знає, як влаштований склад. Дані можуть лежати в PostgreSQL, у файлах або в пам'яті. Їй це байдуже, бо вона спілкується лише з репозиторієм.

2.  **Централізація (Centralization):**
    Весь код для доступу до таблиці `users` знаходиться в одному місці — `UserRepository`. Весь код для `activity` — в `ActivityRepository`. Це допомагає уникнути дублювання коду (принцип DRY - Don't Repeat Yourself).

3.  **Тестованість (Testability):**
    Під час тестування бізнес-логіки ми можемо "підмінити" справжнього архіваріуса (який лізе в БД) на "фейкового" (який бере дані зі списку в пам'яті). Це робить тести швидкими та незалежними від бази даних.

---

## 2. Практичний приклад (Ваш старий проєкт)

У вашому початковому проєкті ви реалізували цей патерн вручну:

* **`models.py`:** Описував сутності у вигляді `dataclass` (просто контейнери для даних).
* **`repository_interface.py`:** Створював "контракт" `IRepository` (абстрактний клас, який казав, що *повинен* вміти кожен репозиторій: `get_by_id`, `get_all`, `add`).
* **`repos/activity.py`:** Був конкретною реалізацією "архіваріуса" (`ActivityRepository`), який вручну писав SQL-запити (`SELECT * FROM activity...`).
* **`repositories.py`:** Був єдиною точкою входу (`DataAccessLayer`), яка давала доступ до всіх "архіваріусів": `db.activities`, `db.users` тощо.

---

## 3. Як Django реалізує цей патерн (Ваш новий проєкт)

Коли ми перенесли проєкт на Django, ми **замінили** вашу ручну реалізацію репозиторія на професійний, вбудований інструмент.

У Django вам **не потрібно** писати репозиторії власноруч. **Django ORM (Object-Relational Mapper) — це і є ваш вбудований, потужний "Репозиторій".**

Ось як це працює:

1.  **Сутності (Models):**
    Ваш новий `activities/models.py` — це не просто опис даних. Кожен клас, що наслідує `models.Model`, автоматично стає і описом сутності, і репозиторієм для неї.

2.  **Точка доступу:**
    Замість `db.activities` (з вашого `DataAccessLayer`), Django автоматично додає до кожної моделі "менеджер" на ім'я **`.objects`**.

### Порівняння вашої роботи:

| Операція | Ваш старий код (ручний репозиторій) | Ваш новий код (Django ORM) |
| :--- | :--- | :--- |
| **Вичитка всіх даних** | `db.activities.get_all()` | `Activity.objects.all()` |
| **Пошук по ID** | `db.activities.get_by_id(1)` | `Activity.objects.get(id=1)` |
| **Запис екземпляра** | `db.activities.add(activity1)` | `activity1.save()` |
| **Де знаходиться SQL?** | Ви писали SQL вручну в `activity.py` | Django сам генерує SQL під капотом |

### Висновок

Ви виконали завдання лабораторної роботи, перейшовши від ручної реалізації патерну "Репозиторій" до використання професійної, вбудованої реалізації (Django ORM). Це дозволило видалити весь код доступу до даних (всі файли з папки `repos`) і замінити його на чисті, безпечні та потужні методи Django (`.all()`, `.get()`, `.create()`, `.save()`).